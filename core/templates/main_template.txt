# +====================================================================+
# | Model: [PLACEHOLDER-MODEL_NAME]                                    |
# | Last update: [PLACEHOLDER-DATE]                                    |
# +====================================================================+


# +====================================================================+
# | IMPORTS                                                            |
# +====================================================================+
from pyflamegpu import *


# +====================================================================+
# | GLOBAL PARAMETERS                                                  |
# +====================================================================+
# MANUALLY REPLACE ALL ? BY ACTUAL VALUES OF YOUR MODEL. CHECK ALL 'TODO' COMMENTs
[PLACEHOLDER-ALL_GLOBALS]
STEPS = ?
TIME_STEP = ?
EPSILON = 0.0000000001
MAX_EXPECTED_BOUNDARY_POS = ?
MIN_EXPECTED_BOUNDARY_POS = -?
MAX_SEARCH_RADIUS_[PLACEHOLDER-AGENT_i_NAME] = ?

# +====================================================================+
# | FLAMEGPU2 IMPLEMENTATION                                           |
# +====================================================================+
# Files containing agent functions for agents, which outputs publicly visible properties to a message list


"""
  [PLACEHOLDER-AGENT_i_NAME]  
"""
[PLACEHOLDER-AGENT_NAME_i_FUNCTION_j]_file = "[PLACEHOLDER-AGENT_NAME_i_FUNCTION_j].cpp"


model = pyflamegpu.ModelDescription([PLACEHOLDER-MODEL_NAME])

"""
  GLOBAL SETTINGS
"""
env = model.Environment()
# Starting ID to generate agent populations
env.newPropertyUInt("CURRENT_ID", 0)
# Number of steps to simulate
env.newPropertyUInt("STEPS", STEPS)
# Time increment 
env.newPropertyFloat("TIME_STEP", TIME_STEP)

# Model globals
env.[PLACEHOLDER_GLOBAL_TYPE]("[PLACEHOLDER-GLOBAL_i]", [PLACEHOLDER-GLOBAL_i_value])


# Other globals
env.newPropertyFloat("PI", 3.1415)
env.newPropertyUInt("DEBUG_PRINTING", DEBUG_PRINTING)
env.newPropertyFloat("EPSILON", EPSILON)

"""
  LOCATION MESSAGES
"""

[PLACEHOLDER-AGENT_i_NAME]_[PLACEHOLDER_MESSAGE_TYPE_KEY]_location_message = model.new[PLACEHOLDER_MESSAGE_TYPE]("[PLACEHOLDER-AGENT_i_NAME]_[PLACEHOLDER_MESSAGE_TYPE_KEY]_location_message")


"""
  AGENTS
"""


"""
  [PLACEHOLDER-AGENT_i_NAME] agent
"""
[PLACEHOLDER-AGENT_i_NAME]_agent = model.newAgent("[PLACEHOLDER-AGENT_i_NAME]")
fnode_agent.newVariableInt("id")
fnode_agent.newVariableFloat("x")
fnode_agent.newVariableFloat("y")
fnode_agent.newVariableFloat("z")
fnode_agent.newVariableFloat("vx", 0.0)
fnode_agent.newVariableFloat("vy", 0.0)
fnode_agent.newVariableFloat("vz", 0.0)
fnode_agent.newVariableFloat("fx", 0.0)
fnode_agent.newVariableFloat("fy", 0.0)
fnode_agent.newVariableFloat("fz", 0.0)
fnode_agent.newVariableFloat("k_elast")
fnode_agent.newVariableFloat("d_dumping")
fnode_agent.newVariableFloat("mass")
fnode_agent.newVariableFloat("boundary_fx")  # boundary_f[A]: normal force coming from boundary [A] when elastic boundaries option is selected.
fnode_agent.newVariableFloat("boundary_fy")
fnode_agent.newVariableFloat("boundary_fz")
fnode_agent.newVariableFloat("f_bx_pos")  # f_b[A]_[B]: normal force transmitted to the boundary [A]_[B] when agent is clamped
fnode_agent.newVariableFloat("f_bx_neg")
fnode_agent.newVariableFloat("f_by_pos")
fnode_agent.newVariableFloat("f_by_neg")
fnode_agent.newVariableFloat("f_bz_pos")
fnode_agent.newVariableFloat("f_bz_neg")
fnode_agent.newVariableFloat("f_bx_pos_y")  # f_b[A]_[B]_[C]: shear force transmitted to the boundary [A]_[B] in the direction [C] when agent is clamped
fnode_agent.newVariableFloat("f_bx_pos_z")
fnode_agent.newVariableFloat("f_bx_neg_y")
fnode_agent.newVariableFloat("f_bx_neg_z")
fnode_agent.newVariableFloat("f_by_pos_x")
fnode_agent.newVariableFloat("f_by_pos_z")
fnode_agent.newVariableFloat("f_by_neg_x")
fnode_agent.newVariableFloat("f_by_neg_z")
fnode_agent.newVariableFloat("f_bz_pos_x")
fnode_agent.newVariableFloat("f_bz_pos_y")
fnode_agent.newVariableFloat("f_bz_neg_x")
fnode_agent.newVariableFloat("f_bz_neg_y")
fnode_agent.newVariableFloat("f_extension")
fnode_agent.newVariableFloat("f_compression")
fnode_agent.newVariableFloat("elastic_energy")
fnode_agent.newVariableArrayFloat("linked_nodes", MAX_CONNECTIVITY)
fnode_agent.newVariableUInt8("clamped_bx_pos")
fnode_agent.newVariableUInt8("clamped_bx_neg")
fnode_agent.newVariableUInt8("clamped_by_pos")
fnode_agent.newVariableUInt8("clamped_by_neg")
fnode_agent.newVariableUInt8("clamped_bz_pos")
fnode_agent.newVariableUInt8("clamped_bz_neg")


fnode_agent.newRTCFunctionFile("fnode_spatial_location_data", fnode_spatial_location_data_file).setMessageOutput(
    "fnode_spatial_location_message")
fnode_agent.newRTCFunctionFile("fnode_bucket_location_data", fnode_bucket_location_data_file).setMessageOutput(
    "fnode_bucket_location_message")
fnode_agent.newRTCFunctionFile("fnode_boundary_interaction", fnode_boundary_interaction_file)
fnode_agent.newRTCFunctionFile("fnode_fnode_spatial_interaction", fnode_fnode_spatial_interaction_file).setMessageInput(
    "fnode_spatial_location_message")
fnode_agent.newRTCFunctionFile("fnode_fnode_bucket_interaction", fnode_fnode_bucket_interaction_file).setMessageInput(
    "fnode_bucket_location_message")
fnode_agent.newRTCFunctionFile("fnode_move", fnode_move_file)



"""
  Population initialisation functions
"""


# This class is used to ensure that corner agents are assigned the first 8 ids
class initAgentPopulations(pyflamegpu.HostFunction):
    def run(self, FLAMEGPU):
        global N_NODES, INITIAL_NETWORK_CONNECTIVITY, NODE_COORDS, MAX_CONNECTIVITY
        # BOUNDARY CORNERS
        current_id = FLAMEGPU.environment.getPropertyUInt("CURRENT_ID")
        coord_boundary = FLAMEGPU.environment.getPropertyArrayFloat("COORDS_BOUNDARIES")
        coord_boundary_x_pos = coord_boundary[0]
        coord_boundary_x_neg = coord_boundary[1]
        coord_boundary_y_pos = coord_boundary[2]
        coord_boundary_y_neg = coord_boundary[3]
        coord_boundary_z_pos = coord_boundary[4]
        coord_boundary_z_neg = coord_boundary[5]
        print("CORNERS:")
        print("current_id:", current_id)

        for i in range(1, 9):
            instance = FLAMEGPU.agent("BCORNER").newAgent()
            instance.setVariableInt("id", current_id + i)
            if i == 1:
                # +x,+y,+z
                instance.setVariableFloat("x", coord_boundary_x_pos)
                instance.setVariableFloat("y", coord_boundary_y_pos)
                instance.setVariableFloat("z", coord_boundary_z_pos)
            elif i == 2:
                # -x,+y,+z
                instance.setVariableFloat("x", coord_boundary_x_neg)
                instance.setVariableFloat("y", coord_boundary_y_pos)
                instance.setVariableFloat("z", coord_boundary_z_pos)
            elif i == 3:
                # -x,-y,+z
                instance.setVariableFloat("x", coord_boundary_x_neg)
                instance.setVariableFloat("y", coord_boundary_y_neg)
                instance.setVariableFloat("z", coord_boundary_z_pos)
            elif i == 4:
                # +x,-y,+z
                instance.setVariableFloat("x", coord_boundary_x_pos)
                instance.setVariableFloat("y", coord_boundary_y_neg)
                instance.setVariableFloat("z", coord_boundary_z_pos)
            elif i == 5:
                # +x,+y,-z
                instance.setVariableFloat("x", coord_boundary_x_pos)
                instance.setVariableFloat("y", coord_boundary_y_pos)
                instance.setVariableFloat("z", coord_boundary_z_neg)
            elif i == 6:
                # -x,+y,-z
                instance.setVariableFloat("x", coord_boundary_x_neg)
                instance.setVariableFloat("y", coord_boundary_y_pos)
                instance.setVariableFloat("z", coord_boundary_z_neg)
            elif i == 7:
                # -x,-y,-z
                instance.setVariableFloat("x", coord_boundary_x_neg)
                instance.setVariableFloat("y", coord_boundary_y_neg)
                instance.setVariableFloat("z", coord_boundary_z_neg)
            elif i == 8:
                # +x,-y,-z
                instance.setVariableFloat("x", coord_boundary_x_pos)
                instance.setVariableFloat("y", coord_boundary_y_neg)
                instance.setVariableFloat("z", coord_boundary_z_neg)
            else:
                sys.exit("Bad initialization of boundary corners!")

        FLAMEGPU.environment.setPropertyUInt("CURRENT_ID", 8)

        # FIBRE NODES
        k_elast = FLAMEGPU.environment.getPropertyFloat("FIBRE_SEGMENT_K_ELAST")
        d_dumping = FLAMEGPU.environment.getPropertyFloat("FIBRE_SEGMENT_D_DUMPING")
        mass = FLAMEGPU.environment.getPropertyFloat("FIBRE_SEGMENT_MASS")
        current_id = FLAMEGPU.environment.getPropertyUInt("CURRENT_ID")
        current_id += 1
        print("FIBRE NODES:")
        print("current_id:", current_id)    
        count = -1
        offset = current_id
        for fn in range(N_NODES):
            x = NODE_COORDS[fn, 0]
            y = NODE_COORDS[fn, 1]
            z = NODE_COORDS[fn, 2]
            linked_nodes = np.array(INITIAL_NETWORK_CONNECTIVITY.get(fn, []))   
            # Add the offset to all values above 0
            linked_nodes = np.where(linked_nodes > 0, linked_nodes + offset, linked_nodes) 
            count += 1
            instance = FLAMEGPU.agent("FNODE").newAgent()
            instance.setVariableInt("id", current_id + count)
            instance.setVariableFloat("x", x)
            instance.setVariableFloat("y", y)
            instance.setVariableFloat("z", z)            
            instance.setVariableFloat("vy", 0.0)
            instance.setVariableFloat("vz", 0.0)
            instance.setVariableFloat("vx", 0.0)
            instance.setVariableFloat("fx", 0.0)
            instance.setVariableFloat("fy", 0.0)
            instance.setVariableFloat("fz", 0.0)
            instance.setVariableFloat("k_elast", k_elast)
            instance.setVariableFloat("d_dumping", d_dumping)
            instance.setVariableFloat("mass", mass)
            instance.setVariableFloat("boundary_fx", 0.0)
            instance.setVariableFloat("boundary_fy", 0.0)
            instance.setVariableFloat("boundary_fz", 0.0)
            instance.setVariableFloat("f_bx_pos", 0.0)
            instance.setVariableFloat("f_bx_neg", 0.0)
            instance.setVariableFloat("f_by_pos", 0.0)
            instance.setVariableFloat("f_by_neg", 0.0)
            instance.setVariableFloat("f_bz_pos", 0.0)
            instance.setVariableFloat("f_bz_neg", 0.0)
            instance.setVariableFloat("f_bx_pos_y", 0.0)
            instance.setVariableFloat("f_bx_pos_z", 0.0)
            instance.setVariableFloat("f_bx_neg_y", 0.0)
            instance.setVariableFloat("f_bx_neg_z", 0.0)
            instance.setVariableFloat("f_by_pos_x", 0.0)
            instance.setVariableFloat("f_by_pos_z", 0.0)
            instance.setVariableFloat("f_by_neg_x", 0.0)
            instance.setVariableFloat("f_by_neg_z", 0.0)
            instance.setVariableFloat("f_bz_pos_x", 0.0)
            instance.setVariableFloat("f_bz_pos_y", 0.0)
            instance.setVariableFloat("f_bz_neg_x", 0.0)
            instance.setVariableFloat("f_bz_neg_y", 0.0)
            instance.setVariableFloat("f_extension", 0.0)
            instance.setVariableFloat("f_compression", 0.0)
            instance.setVariableFloat("elastic_energy", 0.0)
            instance.setVariableUInt8("clamped_bx_pos", 0)
            instance.setVariableUInt8("clamped_bx_neg", 0)
            instance.setVariableUInt8("clamped_by_pos", 0)
            instance.setVariableUInt8("clamped_by_neg", 0)
            instance.setVariableUInt8("clamped_bz_pos", 0)
            instance.setVariableUInt8("clamped_bz_neg", 0)
            instance.setVariableArrayFloat("linked_nodes", linked_nodes.tolist())            


        FLAMEGPU.environment.setPropertyUInt("CURRENT_ID", current_id + count)
        
        return


# Add function callback to INIT functions for population generation
initialAgentPopulation = initAgentPopulations()
model.addInitFunction(initialAgentPopulation)

"""
  STEP FUNCTIONS
"""


class MoveBoundaries(pyflamegpu.HostFunction):
    """
     pyflamegpu requires step functions to be a class which extends the StepFunction base class.
     This class must extend the handle function
     """

    # Define Python class 'constructor'
    def __init__(self):
        super().__init__()
        self.apply_parallel_disp = list()
        for d in range(12):
            if abs(BOUNDARY_DISP_RATES_PARALLEL[d]) > 0.0:
                self.apply_parallel_disp.append(True)
            else:
                self.apply_parallel_disp.append(False)

    # Override C++ method: virtual void run(FLAMEGPU_HOST_API*)
    def run(self, FLAMEGPU):
        stepCounter = FLAMEGPU.getStepCounter() + 1
        global BOUNDARY_DISP_RATES, ALLOW_BOUNDARY_ELASTIC_MOVEMENT, BOUNDARY_STIFFNESS, BOUNDARY_DUMPING, BPOS_OVER_TIME
        global CLAMP_AGENT_TOUCHING_BOUNDARY, OSCILLATORY_SHEAR_ASSAY, OSCILLATORY_AMPLITUDE, OSCILLATORY_W, OSCILLATORY_STRAIN_OVER_TIME
        global DEBUG_PRINTING, PAUSE_EVERY_STEP, TIME_STEP

        boundaries_moved = False
        if PAUSE_EVERY_STEP:
            input()  # pause everystep
    
        coord_boundary = list(FLAMEGPU.environment.getPropertyArrayFloat("COORDS_BOUNDARIES"))
        if OSCILLATORY_SHEAR_ASSAY:
            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:
                new_val = pd.DataFrame([OSOT(OSCILLATORY_AMPLITUDE * math.sin(OSCILLATORY_W * stepCounter))])
                # OSCILLATORY_STRAIN_OVER_TIME = OSCILLATORY_STRAIN_OVER_TIME.append(new_val, ignore_index=True) #TODO: FIX?
                OSCILLATORY_STRAIN_OVER_TIME = pd.concat([OSCILLATORY_STRAIN_OVER_TIME, new_val], ignore_index=True)
            for d in range(12):
                if self.apply_parallel_disp[d]:
                    BOUNDARY_DISP_RATES_PARALLEL[d] = OSCILLATORY_AMPLITUDE * math.cos(
                        OSCILLATORY_W * stepCounter) * OSCILLATORY_W / TIME_STEP  # cos(w*t)*t is used because the slope of the sin(w*t) function is needed

            FLAMEGPU.environment.setPropertyArrayFloat("DISP_RATES_BOUNDARIES_PARALLEL", BOUNDARY_DISP_RATES_PARALLEL)

        if any(catb < 1 for catb in CLAMP_AGENT_TOUCHING_BOUNDARY) or any(
                abem > 0 for abem in ALLOW_BOUNDARY_ELASTIC_MOVEMENT):
            boundaries_moved = True
            agent = FLAMEGPU.agent("FNODE")
            minmax_positions = list()
            minmax_positions.append(agent.maxFloat("x"))
            minmax_positions.append(agent.minFloat("x"))
            minmax_positions.append(agent.maxFloat("y"))
            minmax_positions.append(agent.minFloat("y"))
            minmax_positions.append(agent.maxFloat("z"))
            minmax_positions.append(agent.minFloat("z"))
            boundary_equil_distances = list()
            boundary_equil_distances.append(FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            boundary_equil_distances.append(-FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            boundary_equil_distances.append(FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            boundary_equil_distances.append(-FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            boundary_equil_distances.append(FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            boundary_equil_distances.append(-FIBRE_NODE_BOUNDARY_EQUILIBRIUM_DISTANCE)
            for i in range(6):
                if CLAMP_AGENT_TOUCHING_BOUNDARY[i] < 1:
                    if ALLOW_BOUNDARY_ELASTIC_MOVEMENT[i] > 0:
                        coord_boundary[i] = minmax_positions[i] + boundary_equil_distances[i]
                    else:
                        coord_boundary[i] = minmax_positions[i]

            bcs = [coord_boundary[0], coord_boundary[1], coord_boundary[2], coord_boundary[3], coord_boundary[4],
                   coord_boundary[5]]  # +X,-X,+Y,-Y,+Z,-Z
            FLAMEGPU.environment.setPropertyArrayFloat("COORDS_BOUNDARIES", bcs)

            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:
                print("====== MOVING FREE BOUNDARIES  ======")
                print("New boundary positions [+X,-X,+Y,-Y,+Z,-Z]: ", coord_boundary)
                print("=====================================")

        if any(dr > 0.0 or dr < 0.0 for dr in BOUNDARY_DISP_RATES):
            boundaries_moved = True
            for i in range(6):
                coord_boundary[i] += (BOUNDARY_DISP_RATES[i] * TIME_STEP)

            bcs = [coord_boundary[0], coord_boundary[1], coord_boundary[2], coord_boundary[3], coord_boundary[4],
                   coord_boundary[5]]  # +X,-X,+Y,-Y,+Z,-Z
            FLAMEGPU.environment.setPropertyArrayFloat("COORDS_BOUNDARIES", bcs)
            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:
                print("====== MOVING BOUNDARIES DUE TO CONDITIONS ======")
                print("New boundary positions [+X,-X,+Y,-Y,+Z,-Z]: ", coord_boundary)
                print("=================================================")

        if boundaries_moved:
            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:
                new_pos = pd.DataFrame([BPOS(coord_boundary[0], coord_boundary[1], coord_boundary[2],
                                             coord_boundary[3], coord_boundary[4], coord_boundary[5])])
                # BPOS_OVER_TIME = BPOS_OVER_TIME.append(new_pos, ignore_index=True)
                BPOS_OVER_TIME = pd.concat([BPOS_OVER_TIME, new_pos], ignore_index=True)

        # print ("End of step: ", stepCounter)


class SaveDataToFile(pyflamegpu.HostFunction):
    def __init__(self):
        global N_NODES
        super().__init__()
        self.header = list()
        self.header.append("# vtk DataFile Version 3.0")
        self.header.append("FIBRE NETWORK data")
        self.header.append("ASCII")
        self.header.append("DATASET UNSTRUCTURED_GRID")
        # self.header.append("POINTS {} float".format(8 + N_NODES))  # number of FNODE agents + 8 corners
        # self.header.append("POINTS {} float".format(8))
        self.domaindata = list()
        cube_conn = [[4, 0, 3, 7, 4],
                     [4, 1, 2, 6, 5], 
                     [4, 1, 0, 4, 5], 
                     [4, 2, 3, 7, 6], 
                     [4, 0, 1, 2, 3],
                     [4, 4, 5, 6, 7]]
        for i in range(len(cube_conn)):
            for j in range(len(cube_conn[i])):
                if j > 0:
                    cube_conn[i][j] = cube_conn[i][j] + N_NODES
            self.domaindata.append(' '.join(str(x) for x in cube_conn[i]))


    def run(self, FLAMEGPU):
        global SAVE_DATA_TO_FILE, SAVE_EVERY_N_STEPS
        global RES_PATH, ENSEMBLE
        global fileCounter
        global INITIAL_NETWORK_CONNECTIVITY
        
        stepCounter = FLAMEGPU.getStepCounter() + 1
        
        coord_boundary = list(FLAMEGPU.environment.getPropertyArrayFloat("COORDS_BOUNDARIES"))

        if SAVE_DATA_TO_FILE:
            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:

                file_name = 'fibre_network_data_t{:04d}.vtk'.format(stepCounter)
                file_path = RES_PATH / file_name

                agent = FLAMEGPU.agent("FNODE")
                # reaction forces, thus, opposite to agent-applied forces
                sum_bx_pos = -agent.sumFloat("f_bx_pos")
                sum_bx_neg = -agent.sumFloat("f_bx_neg")
                sum_by_pos = -agent.sumFloat("f_by_pos")
                sum_by_neg = -agent.sumFloat("f_by_neg")
                sum_bz_pos = -agent.sumFloat("f_bz_pos")
                sum_bz_neg = -agent.sumFloat("f_bz_neg")
                sum_bx_pos_y = -agent.sumFloat("f_bx_pos_y")
                sum_bx_pos_z = -agent.sumFloat("f_bx_pos_z")
                sum_bx_neg_y = -agent.sumFloat("f_bx_neg_y")
                sum_bx_neg_z = -agent.sumFloat("f_bx_neg_z")
                sum_by_pos_x = -agent.sumFloat("f_by_pos_x")
                sum_by_pos_z = -agent.sumFloat("f_by_pos_z")
                sum_by_neg_x = -agent.sumFloat("f_by_neg_x")
                sum_by_neg_z = -agent.sumFloat("f_by_neg_z")
                sum_bz_pos_x = -agent.sumFloat("f_bz_pos_x")
                sum_bz_pos_y = -agent.sumFloat("f_bz_pos_y")
                sum_bz_neg_x = -agent.sumFloat("f_bz_neg_x")
                sum_bz_neg_y = -agent.sumFloat("f_bz_neg_y")

                ids = list()
                coords = list()
                velocity = list()
                force = list()
                elastic_energy = list()

                av = agent.getPopulationData()  # this returns a DeviceAgentVector
                for ai in av:
                    id_ai = ai.getVariableInt("id") - 9 # for vtk visualization, FNODE agents start at 0
                    coords_ai = (ai.getVariableFloat("x"), ai.getVariableFloat("y"), ai.getVariableFloat("z"))
                    velocity_ai = (ai.getVariableFloat("vx"), ai.getVariableFloat("vy"), ai.getVariableFloat("vz"))
                    force_ai = (ai.getVariableFloat("fx"), ai.getVariableFloat("fy"), ai.getVariableFloat("fz"))
                    ids.append(id_ai)
                    coords.append(coords_ai)
                    velocity.append(velocity_ai)
                    force.append(force_ai)
                    elastic_energy.append(ai.getVariableFloat("elastic_energy"))
                    
                # Get sorting indices based on ids
                sorted_indices = np.argsort(ids)

                # Rearrange lists according to the sorted indices
                ids = [ids[i] for i in sorted_indices]
                coords = [coords[i] for i in sorted_indices]
                velocity = [velocity[i] for i in sorted_indices]
                force = [force[i] for i in sorted_indices]
                elastic_energy = [elastic_energy[i] for i in sorted_indices]
                print("====== SAVING DATA FROM Step {:03d} TO FILE ======".format(stepCounter))
                # Extract lines from INITIAL_NETWORK_CONNECTIVITY
                # To avoid duplicating cells, use a set to keep track of added lines
                added_lines = set()
                cell_connectivity = []
                
                for node_index, connections in INITIAL_NETWORK_CONNECTIVITY.items():
                    for connected_node_index in connections:
                        if connected_node_index != -1:
                            # Create a tuple with sorted indices to ensure uniqueness
                            line = tuple(sorted((node_index, connected_node_index)))
                            if line not in added_lines:
                                added_lines.add(line)
                                cell_connectivity.append(line)
                
                num_cells = len(cell_connectivity)
                
                
                with open(str(file_path), 'w') as file:
                    for line in self.header:
                        file.write(line + '\n')
                        
                    file.write("POINTS {} float \n".format(8 + N_NODES))
                    for coords_ai in coords:
                        file.write("{} {} {} \n".format(coords_ai[0], coords_ai[1], coords_ai[2]))
                    # Write boundary positions at the end so that corner points don't cover the points underneath
                    file.write("{} {} {} \n".format(coord_boundary[0], coord_boundary[2], coord_boundary[4]))
                    file.write("{} {} {} \n".format(coord_boundary[1], coord_boundary[2], coord_boundary[4]))
                    file.write("{} {} {} \n".format(coord_boundary[1], coord_boundary[3], coord_boundary[4]))
                    file.write("{} {} {} \n".format(coord_boundary[0], coord_boundary[3], coord_boundary[4]))
                    file.write("{} {} {} \n".format(coord_boundary[0], coord_boundary[2], coord_boundary[5]))
                    file.write("{} {} {} \n".format(coord_boundary[1], coord_boundary[2], coord_boundary[5]))
                    file.write("{} {} {} \n".format(coord_boundary[1], coord_boundary[3], coord_boundary[5]))
                    file.write("{} {} {} \n".format(coord_boundary[0], coord_boundary[3], coord_boundary[5]))
                        
                    # Write the cell connectivity
                    file.write(f"CELLS {num_cells + 6} {num_cells * 3 + 6 * 5}\n") # each of the 6 boundaries is a cell of type POLYGON with 4 nodes
                    for conn in cell_connectivity:
                        file.write(f"2 {conn[0]} {conn[1]}\n") 
                    for line in self.domaindata:
                        file.write(line + '\n')
                    
                    # Write the cell types (3 for VTK_LINE)
                    file.write(f"CELL_TYPES {num_cells + 6}\n")
                    for _ in range(num_cells):
                        file.write("3\n")  # VTK_LINE  
                    for _ in range(6):
                        file.write("7\n")  # VTK_POLYGON 
                        
                    file.write(f"CELL_DATA {num_cells + 6}\n")
                    file.write("SCALARS boundary_idx int 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')                    
                    for _ in range(num_cells):
                        file.write("0\n")    
                    for bidx in range(6):
                        file.write(f"{bidx + 1}\n") 

                    file.write("SCALARS boundary_normal_forces float 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')                    
                    for _ in range(num_cells):
                        file.write("0.0\n")    
                    file.write(str(sum_bx_pos) + '\n')
                    file.write(str(sum_bx_neg) + '\n')
                    file.write(str(sum_by_pos) + '\n')
                    file.write(str(sum_by_neg) + '\n')
                    file.write(str(sum_bz_pos) + '\n')
                    file.write(str(sum_bz_neg) + '\n')
                    
                    file.write("SCALARS boundary_normal_force_scaling float 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')
                    for _ in range(num_cells):
                        file.write("0.0\n")    
                    file.write(str(abs(sum_bx_pos)) + '\n')
                    file.write(str(abs(sum_bx_neg)) + '\n')
                    file.write(str(abs(sum_by_pos)) + '\n')
                    file.write(str(abs(sum_by_neg)) + '\n')
                    file.write(str(abs(sum_bz_pos)) + '\n')
                    file.write(str(abs(sum_bz_neg)) + '\n')
                    # must be divided in blocks of 6 (one value per face of the cube)
                    file.write("SCALARS boundary_shear_forces_pos float 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')
                    for _ in range(num_cells):
                        file.write("0.0\n")    
                    file.write(str(sum_bx_pos_y) + '\n')
                    file.write(str(sum_bx_pos_z) + '\n')
                    file.write(str(sum_by_pos_x) + '\n')
                    file.write(str(sum_by_pos_z) + '\n')
                    file.write(str(sum_bz_pos_x) + '\n')
                    file.write(str(sum_bz_pos_y) + '\n')
                    file.write("SCALARS boundary_shear_forces_neg float 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')
                    for _ in range(num_cells):
                        file.write("0.0\n")    
                    file.write(str(sum_bx_neg_y) + '\n')
                    file.write(str(sum_bx_neg_z) + '\n')
                    file.write(str(sum_by_neg_x) + '\n')
                    file.write(str(sum_by_neg_z) + '\n')
                    file.write(str(sum_bz_neg_x) + '\n')
                    file.write(str(sum_bz_neg_y) + '\n')


                    file.write("POINT_DATA {} \n".format(8 + N_NODES))  # 8 corners + number of FNODE agents

                    file.write(
                        "SCALARS is_corner int 1" + '\n')  # create this variable to remove them from representations
                    file.write("LOOKUP_TABLE default" + '\n')

                    for ee_ai in elastic_energy:
                        file.write("{0} \n".format(0))
                    for i in range(8):
                        file.write("1 \n")  # boundary corners

                    file.write("SCALARS elastic_energy float 1" + '\n')
                    file.write("LOOKUP_TABLE default" + '\n')
                    for ee_ai in elastic_energy:
                        file.write("{:.4f} \n".format(ee_ai))
                    for i in range(8):
                        file.write("0.0 \n")  # boundary corners


                    file.write("VECTORS velocity float" + '\n')
                    for v_ai in velocity:
                        file.write("{:.4f} {:.4f} {:.4f} \n".format(v_ai[0], v_ai[1], v_ai[2]))
                    for i in range(8):
                        file.write("0.0 0.0 0.0 \n")  # boundary corners

                    file.write("VECTORS force float" + '\n')
                    for f_ai in force:
                        file.write("{:.4f} {:.4f} {:.4f} \n".format(f_ai[0], f_ai[1], f_ai[2]))
                    for i in range(8):
                        file.write("0.0 0.0 0.0 \n")  # boundary corners


                print("... succesful save ")
                print("=================================")


            

sdf = SaveDataToFile()
model.addStepFunction(sdf)

mb = MoveBoundaries()
model.addStepFunction(mb)

"""
  END OF STEP FUNCTIONS
"""

"""
  Control flow
"""
# First set of layers: location of agents
layer_count = 1
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_spatial_location_data")
model.Layer("L" + str(layer_count)).addAgentFunction("BCORNER", "bcorner_output_location_data")

layer_count += 1
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_bucket_location_data")

layer_count += 1
# Second set of layers: interaction with boundaries and between FNODE agents
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_boundary_interaction")
layer_count += 1
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_fnode_spatial_interaction")
layer_count += 1
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_fnode_bucket_interaction")

layer_count += 1
# Third set of layers: agent movement
model.newLayer("L" + str(layer_count)).addAgentFunction("FNODE", "fnode_move")
model.Layer("L" + str(layer_count)).addAgentFunction("BCORNER", "bcorner_move")


# Create and configure logging details 
logging_config = pyflamegpu.LoggingConfig(model)
logging_config.logEnvironment("CURRENT_ID")
logging_config.logEnvironment("COORDS_BOUNDARIES")
fnode_agent_log = logging_config.agent("FNODE")
fnode_agent_log.logCount()
fnode_agent_log.logSumFloat("f_bx_pos")
fnode_agent_log.logSumFloat("f_bx_neg")
fnode_agent_log.logSumFloat("f_by_pos")
fnode_agent_log.logSumFloat("f_by_neg")
fnode_agent_log.logSumFloat("f_bz_pos")
fnode_agent_log.logSumFloat("f_bz_neg")

fnode_agent_log.logSumFloat("f_bx_pos_y")
fnode_agent_log.logSumFloat("f_bx_pos_z")
fnode_agent_log.logSumFloat("f_bx_neg_y")
fnode_agent_log.logSumFloat("f_bx_neg_z")
fnode_agent_log.logSumFloat("f_by_pos_x")
fnode_agent_log.logSumFloat("f_by_pos_z")
fnode_agent_log.logSumFloat("f_by_neg_x")
fnode_agent_log.logSumFloat("f_by_neg_z")
fnode_agent_log.logSumFloat("f_bz_pos_x")
fnode_agent_log.logSumFloat("f_bz_pos_y")
fnode_agent_log.logSumFloat("f_bz_neg_x")
fnode_agent_log.logSumFloat("f_bz_neg_y")

fnode_agent_log.logMeanFloat("f_bx_pos")
fnode_agent_log.logMeanFloat("f_bx_neg")
fnode_agent_log.logMeanFloat("f_by_pos")
fnode_agent_log.logMeanFloat("f_by_neg")
fnode_agent_log.logMeanFloat("f_bz_pos")
fnode_agent_log.logMeanFloat("f_bz_neg")
fnode_agent_log.logStandardDevFloat("f_bx_pos")
fnode_agent_log.logStandardDevFloat("f_bx_neg")
fnode_agent_log.logStandardDevFloat("f_by_pos")
fnode_agent_log.logStandardDevFloat("f_by_neg")
fnode_agent_log.logStandardDevFloat("f_bz_pos")
fnode_agent_log.logStandardDevFloat("f_bz_neg")

step_log = pyflamegpu.StepLoggingConfig(logging_config)
step_log.setFrequency(1)

"""
  Create Model Runner
"""
simulation = pyflamegpu.CUDASimulation(model)
simulation.SimulationConfig().steps = STEPS
simulation.setStepLog(step_log)
simulation.setExitLog(logging_config)

"""
  Create Visualisation
"""
if pyflamegpu.VISUALISATION and VISUALISATION and not ENSEMBLE:
    visualisation = simulation.getVisualisation()
    # Configure vis
    envWidth = MAX_EXPECTED_BOUNDARY_POS - MIN_EXPECTED_BOUNDARY_POS
    INIT_CAM = MAX_EXPECTED_BOUNDARY_POS * 4.5
    # Visualisation.setInitialCameraLocation(INIT_CAM * 2, INIT_CAM, INIT_CAM)
    visualisation.setInitialCameraLocation(0.0, 0.0, INIT_CAM)
    visualisation.setCameraSpeed(0.002 * envWidth)
    if DEBUG_PRINTING:
        visualisation.setSimulationSpeed(1)
    visualisation.setBeginPaused(True)
    circ_fnode_agt = visualisation.addAgent("FNODE")
    # Position vars are named x, y, z so they are used by default
    circ_fnode_agt.setModel(pyflamegpu.ICOSPHERE)
    # circ_fnode_agt.setModelScale(env.getPropertyFloat("ECM_ECM_INTERACTION_RADIUS")/7.5)
    circ_fnode_agt.setModelScale(0.03 * envWidth)
    circ_fnode_agt.setColor(pyflamegpu.GREEN)
    # circ_fnode_agt.setColor(pyflamegpu.ViridisInterpolation("y", -1.0, 1.0))
    # circ_fnode_agt.setColor(pyflamegpu.HSVInterpolation("y", 0.0, 360.0))
    f_max = FIBRE_SEGMENT_K_ELAST * (FIBRE_SEGMENT_EQUILIBRIUM_DISTANCE)
    max_energy = 0.5 * (f_max * f_max) / FIBRE_SEGMENT_K_ELAST
    print("max force, max energy: ", f_max, max_energy)
    circ_fnode_agt.setColor(pyflamegpu.HSVInterpolation.GREENRED("elastic_energy", 0.00000001, max_energy * 1.0))
    square_bcorner_agt = visualisation.addAgent("BCORNER")
    square_bcorner_agt.setModel(pyflamegpu.CUBE)
    square_bcorner_agt.setModelScale(0.025 * envWidth)
    square_bcorner_agt.setColor(pyflamegpu.RED)
            
    coord_boundary = list(env.getPropertyArrayFloat("COORDS_BOUNDARIES"))
    pen = visualisation.newLineSketch(1, 1, 1, 0.8)
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    visualisation.activate()

"""
  Execution
"""
if ENSEMBLE:
    # Execute the ensemble using the specified RunPlans
    errs = ensemble.simulate(runs_final)
else:
    simulation.simulate()

"""
  Export Pop
"""
# simulation.exportData("end.xml")

# Join Visualisation
if pyflamegpu.VISUALISATION and VISUALISATION and not ENSEMBLE:
    visualisation.join()

print("--- EXECUTION TIME: %s seconds ---" % (time.time() - start_time))


def manageLogs(steps, is_ensemble, idx):
    global SAVE_EVERY_N_STEPS, SAVE_PICKLE, SHOW_PLOTS, RES_PATH, model_config
    global BPOS_OVER_TIME, BFORCE_OVER_TIME, BFORCE_SHEAR_OVER_TIME, OSCILLATORY_STRAIN_OVER_TIME
    ecm_agent_counts = [None] * len(steps)
    counter = 0
    BFORCE = make_dataclass("BFORCE",
                            [("fxpos", float), ("fxneg", float), ("fypos", float), ("fyneg", float), ("fzpos", float),
                             ("fzneg", float)])
    BFORCE_SHEAR = make_dataclass("BFORCE_SHEAR",
                                  [("fxpos_y", float), ("fxpos_z", float), ("fxneg_y", float), ("fxneg_z", float),
                                   ("fypos_x", float), ("fypos_z", float), ("fyneg_x", float), ("fyneg_z", float),
                                   ("fzpos_x", float), ("fzpos_y", float), ("fzneg_x", float), ("fzneg_y", float)])
    for step in steps:
        stepcount = step.getStepCount()
        if stepcount % SAVE_EVERY_N_STEPS == 0 or stepcount == 1:
            ecm_agents = step.getAgent("FNODE")
            ecm_agent_counts[counter] = ecm_agents.getCount()
            f_bx_pos = ecm_agents.getSumFloat("f_bx_pos")
            f_bx_neg = ecm_agents.getSumFloat("f_bx_neg")
            f_by_pos = ecm_agents.getSumFloat("f_by_pos")
            f_by_neg = ecm_agents.getSumFloat("f_by_neg")
            f_bz_pos = ecm_agents.getSumFloat("f_bz_pos")
            f_bz_neg = ecm_agents.getSumFloat("f_bz_neg")
            f_bx_pos_y = ecm_agents.getSumFloat("f_bx_pos_y")
            f_bx_pos_z = ecm_agents.getSumFloat("f_bx_pos_z")
            f_bx_neg_y = ecm_agents.getSumFloat("f_bx_neg_y")
            f_bx_neg_z = ecm_agents.getSumFloat("f_bx_neg_z")
            f_by_pos_x = ecm_agents.getSumFloat("f_by_pos_x")
            f_by_pos_z = ecm_agents.getSumFloat("f_by_pos_z")
            f_by_neg_x = ecm_agents.getSumFloat("f_by_neg_x")
            f_by_neg_z = ecm_agents.getSumFloat("f_by_neg_z")
            f_bz_pos_x = ecm_agents.getSumFloat("f_bz_pos_x")
            f_bz_pos_y = ecm_agents.getSumFloat("f_bz_pos_y")
            f_bz_neg_x = ecm_agents.getSumFloat("f_bz_neg_x")
            f_bz_neg_y = ecm_agents.getSumFloat("f_bz_neg_y")

            step_bforce = pd.DataFrame([BFORCE(f_bx_pos, f_bx_neg, f_by_pos, f_by_neg, f_bz_pos, f_bz_neg)])
            step_bforce_shear = pd.DataFrame([BFORCE_SHEAR(f_bx_pos_y, f_bx_pos_z, f_bx_neg_y, f_bx_neg_z,
                                                           f_by_pos_x, f_by_pos_z, f_by_neg_x, f_by_neg_z,
                                                           f_bz_pos_x, f_bz_pos_y, f_bz_neg_x, f_bz_neg_y)])
            if counter == 0:
                BFORCE_OVER_TIME = pd.DataFrame([BFORCE(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)])
                BFORCE_SHEAR_OVER_TIME = pd.DataFrame(
                    [BFORCE_SHEAR(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)])
            else:
                # BFORCE_OVER_TIME = BFORCE_OVER_TIME.append(step_bforce, ignore_index=True) # deprecated
                BFORCE_OVER_TIME = pd.concat([BFORCE_OVER_TIME, step_bforce], ignore_index=True)
                # BFORCE_SHEAR_OVER_TIME = BFORCE_SHEAR_OVER_TIME.append(step_bforce_shear, ignore_index=True) # deprecated
                BFORCE_SHEAR_OVER_TIME = pd.concat([BFORCE_SHEAR_OVER_TIME, step_bforce_shear], ignore_index=True)
            counter += 1
    if not is_ensemble:
        print()
        print("============================")
        print("BOUNDARY POSITIONS OVER TIME")
        print(BPOS_OVER_TIME)
        print()
        print("============================")
        print("BOUNDARY FORCES OVER TIME")
        print(BFORCE_OVER_TIME)
        print()
        print("============================")
        print("BOUNDARY SHEAR FORCES OVER TIME")
        print(BFORCE_SHEAR_OVER_TIME)
        print()
        print("============================")
        print("STRAIN OVER TIME")
        print(OSCILLATORY_STRAIN_OVER_TIME)
        print()
    # Saving pickle
    # if SAVE_PICKLE:
        # import pickle

        # file_name = f'output_data_{idx}.pickle'
        # file_path = RES_PATH / file_name
        # with open(str(file_path), 'wb') as file:
            # pickle.dump({'BPOS_OVER_TIME': BPOS_OVER_TIME,
                         # 'BFORCE_OVER_TIME': BFORCE_OVER_TIME,
                         # 'BFORCE_SHEAR_OVER_TIME': BFORCE_SHEAR_OVER_TIME,
                         # 'OSCILLATORY_STRAIN_OVER_TIME': OSCILLATORY_STRAIN_OVER_TIME,
                         # 'model_config': model_config},
                        # file, protocol=pickle.HIGHEST_PROTOCOL)

            # print('Results successfully saved to {0}'.format(file_path))
    # Plotting
    # if SHOW_PLOTS and not is_ensemble:
        # # fig,ax=plt.subplots(2,3)
        # fig = plt.figure()
        # gs = fig.add_gridspec(2, 3)
        # ax1 = fig.add_subplot(gs[0, 0])
        # ax2 = fig.add_subplot(gs[0, 1])
        # ax3 = fig.add_subplot(gs[:, 2])
        # ax4 = fig.add_subplot(gs[1, 0])
        # ax5 = fig.add_subplot(gs[1, 1])
        # # BPOS_OVER_TIME.plot()

        # BPOS_OVER_TIME.plot(ax=ax1)
        # # ax = df['size'].plot(secondary_y=True, color='k', marker='o')
        # ax1.set_xlabel('time step')
        # ax1.set_ylabel('pos')
        # BFORCE_OVER_TIME.plot(ax=ax2)
        # ax2.set_ylabel('normal force')
        # ax2.set_xlabel('time step')
        # BFORCE_SHEAR_OVER_TIME.plot(ax=ax3)
        # ax3.set_ylabel('shear force')
        # ax3.set_xlabel('time step')
        # POISSON_RATIO_OVER_TIME.plot(ax=ax4)
        # ax4.set_ylabel('poisson ratio')
        # ax4.set_xlabel('time step')
        # plt.sca(ax5)
        # plt.plot(BPOS_OVER_TIME['ypos'] - 0.5, BFORCE_OVER_TIME['fypos'])
        # ax5.set_ylabel('normal force')
        # ax5.set_xlabel('disp')

        # fig.tight_layout()

        # if OSCILLATORY_SHEAR_ASSAY:
            # OSCILLATORY_STRAIN_OVER_TIME.plot()
            # fig2 = plt.figure()
            # colors = np.arange(0, STEPS + 1, 1).tolist()
            # plt.scatter(OSCILLATORY_STRAIN_OVER_TIME['strain'].abs(), BFORCE_SHEAR_OVER_TIME['fypos_x'].abs(),
                        # marker='o', c=colors, alpha=0.3, cmap='viridis')
            # plt.xlabel('strain')
            # plt.ylabel('shear force')
            # fig3 = plt.figure()
            # colors = np.arange(0, STEPS + 1, 1).tolist()
            # plt.scatter(OSCILLATORY_STRAIN_OVER_TIME['strain'].abs(), BFORCE_SHEAR_OVER_TIME['fypos_x'], marker='o',
                        # c=colors, alpha=0.3, cmap='viridis')
            # plt.xlabel('strain')
            # plt.ylabel('shear force')

            # fig4, ax41 = plt.subplots()
            # x = colors
            # ax42 = ax41.twinx()
            # ax41.plot(x, OSCILLATORY_STRAIN_OVER_TIME['strain'], 'g-')
            # ax42.plot(x, BFORCE_SHEAR_OVER_TIME['fypos_x'], 'b-')

            # ax41.set_xlabel('steps')
            # ax41.set_ylabel('strain', color='g')
            # ax42.set_ylabel('shear force', color='b')
            # ax42.set_ylim(-35, 35)

        # plt.show()


# Deal with logs
if ENSEMBLE:
    logs = simulation.getLogs()
    for i in range(len(logs)):
        steps = logs[i].getStepLog()
        manageLogs(steps, ENSEMBLE, i)
else:
    logs = simulation.getRunLog()
    steps = logs.getStepLog()
    manageLogs(steps, ENSEMBLE, 0)