# +====================================================================+
# | Model: [PLACEHOLDER_MODEL_NAME]                                    |
# | Last update: [PLACEHOLDER_DATE]                                    |
# +====================================================================+


# +====================================================================+
# | IMPORTS                                                            |
# +====================================================================+
from pyflamegpu import *


# +====================================================================+
# | GLOBAL PARAMETERS                                                  |
# +====================================================================+
# MANUALLY REPLACE ALL ? BY ACTUAL VALUES OF YOUR MODEL. CHECK ALL 'TODO' COMMENTs
[PLACEHOLDER_ALL_GLOBALS]
STEPS = ?
TIME_STEP = ?
EPSILON = 0.0000000001
MAX_EXPECTED_BOUNDARY_POS = ?
MIN_EXPECTED_BOUNDARY_POS = -?
MAX_SEARCH_RADIUS_[PLACEHOLDER-AGENT_i_NAME] = ?
SAVE_EVERY_N_STEPS = ?
SAVE_DATA_TO_FILE = False
BOUNDARY_COORDS = [?, ?, ?, ?, ?, ?] # +X,-X,+Y,-Y,+Z,-Z


# +====================================================================+
# | FLAMEGPU2 IMPLEMENTATION                                           |
# +====================================================================+


"""
AGENT Files
"""
# Files containing agent functions for agents, which outputs publicly visible properties to a message list

# Agent function files
[PLACEHOLDER_FUNCTION_FILES]


model = pyflamegpu.ModelDescription([PLACEHOLDER_MODEL_NAME])

"""
  GLOBAL SETTINGS
"""
env = model.Environment()
# Starting ID to generate agent populations
env.newPropertyUInt("CURRENT_ID", 0)
# Number of steps to simulate
env.newPropertyUInt("STEPS", STEPS)
# Time increment 
env.newPropertyFloat("TIME_STEP", TIME_STEP)

# ------------------------------------------------------
# BOUNDARY BEHAVIOUR 
# ------------------------------------------------------
# Boundaries position
bcs = [BOUNDARY_COORDS[0], BOUNDARY_COORDS[1], 
      BOUNDARY_COORDS[2], BOUNDARY_COORDS[3], 
      BOUNDARY_COORDS[4], BOUNDARY_COORDS[5]]  # +X,-X,+Y,-Y,+Z,-Z
env.newPropertyArrayFloat("BOUNDARY_COORDS", bcs)


# Model globals
[PLACEHODER_MODEL_GLOBALS]


# Other globals
env.newPropertyFloat("PI", 3.1415)
env.newPropertyUInt("DEBUG_PRINTING", DEBUG_PRINTING)
env.newPropertyFloat("EPSILON", EPSILON)

"""
  LOCATION MESSAGES
"""
[PLACEHOLDER_MESSAGES]


"""
  AGENTS
"""
[PLACEHOLDER_AGENTS]


"""
  Population initialisation functions
"""


# This class is used to ensure that corner agents are assigned the first 8 ids
class initAgentPopulations(pyflamegpu.HostFunction):
    def run(self, FLAMEGPU):
        # TODO: code the initialization of agents. For example:
        # instance = FLAMEGPU.agent("AGENT_NAME").newAgent()
        # instance.setVariableFloat("VARX", 0.0)
        
        return


# Add function callback to INIT functions for population generation
initialAgentPopulation = initAgentPopulations()
model.addInitFunction(initialAgentPopulation)

"""
  STEP FUNCTIONS
"""
# pyflamegpu requires step functions to be a class which extends the StepFunction base class.
# This class must extend the handle function

class SaveDataToFile(pyflamegpu.HostFunction):
    def __init__(self):
        super().__init__()
        # TODO: code constructor

    def run(self, FLAMEGPU):
    
        global SAVE_DATA_TO_FILE, SAVE_EVERY_N_STEP
        stepCounter = FLAMEGPU.getStepCounter() + 1
        
        if SAVE_DATA_TO_FILE:
            if stepCounter % SAVE_EVERY_N_STEPS == 0 or stepCounter == 1:
                # TODO: code to save data function
                


            

sdf = SaveDataToFile()
model.addStepFunction(sdf)


"""
  END OF STEP FUNCTIONS
"""

"""
  Control flow
"""
[PLACEHOLDER_LAYERS]



# Create and configure logging details 
logging_config = pyflamegpu.LoggingConfig(model)
logging_config.logEnvironment("CURRENT_ID")
logging_config.logEnvironment("COORDS_BOUNDARIES")
fnode_agent_log = logging_config.agent("FNODE")
fnode_agent_log.logCount()
fnode_agent_log.logSumFloat("f_bx_pos")
fnode_agent_log.logSumFloat("f_bx_neg")
fnode_agent_log.logSumFloat("f_by_pos")
fnode_agent_log.logSumFloat("f_by_neg")
fnode_agent_log.logSumFloat("f_bz_pos")
fnode_agent_log.logSumFloat("f_bz_neg")

fnode_agent_log.logSumFloat("f_bx_pos_y")
fnode_agent_log.logSumFloat("f_bx_pos_z")
fnode_agent_log.logSumFloat("f_bx_neg_y")
fnode_agent_log.logSumFloat("f_bx_neg_z")
fnode_agent_log.logSumFloat("f_by_pos_x")
fnode_agent_log.logSumFloat("f_by_pos_z")
fnode_agent_log.logSumFloat("f_by_neg_x")
fnode_agent_log.logSumFloat("f_by_neg_z")
fnode_agent_log.logSumFloat("f_bz_pos_x")
fnode_agent_log.logSumFloat("f_bz_pos_y")
fnode_agent_log.logSumFloat("f_bz_neg_x")
fnode_agent_log.logSumFloat("f_bz_neg_y")

fnode_agent_log.logMeanFloat("f_bx_pos")
fnode_agent_log.logMeanFloat("f_bx_neg")
fnode_agent_log.logMeanFloat("f_by_pos")
fnode_agent_log.logMeanFloat("f_by_neg")
fnode_agent_log.logMeanFloat("f_bz_pos")
fnode_agent_log.logMeanFloat("f_bz_neg")
fnode_agent_log.logStandardDevFloat("f_bx_pos")
fnode_agent_log.logStandardDevFloat("f_bx_neg")
fnode_agent_log.logStandardDevFloat("f_by_pos")
fnode_agent_log.logStandardDevFloat("f_by_neg")
fnode_agent_log.logStandardDevFloat("f_bz_pos")
fnode_agent_log.logStandardDevFloat("f_bz_neg")

step_log = pyflamegpu.StepLoggingConfig(logging_config)
step_log.setFrequency(1)

"""
  Create Model Runner
"""
simulation = pyflamegpu.CUDASimulation(model)
simulation.SimulationConfig().steps = STEPS
simulation.setStepLog(step_log)
simulation.setExitLog(logging_config)

"""
  Create Visualisation
"""
if pyflamegpu.VISUALISATION and VISUALISATION and not ENSEMBLE:
    visualisation = simulation.getVisualisation()
    # Configure vis
    envWidth = MAX_EXPECTED_BOUNDARY_POS - MIN_EXPECTED_BOUNDARY_POS
    INIT_CAM = MAX_EXPECTED_BOUNDARY_POS * 4.5
    # Visualisation.setInitialCameraLocation(INIT_CAM * 2, INIT_CAM, INIT_CAM)
    visualisation.setInitialCameraLocation(0.0, 0.0, INIT_CAM)
    visualisation.setCameraSpeed(0.002 * envWidth)
    if DEBUG_PRINTING:
        visualisation.setSimulationSpeed(1)
    visualisation.setBeginPaused(True)
    circ_fnode_agt = visualisation.addAgent("FNODE")
    # Position vars are named x, y, z so they are used by default
    circ_fnode_agt.setModel(pyflamegpu.ICOSPHERE)
    # circ_fnode_agt.setModelScale(env.getPropertyFloat("ECM_ECM_INTERACTION_RADIUS")/7.5)
    circ_fnode_agt.setModelScale(0.03 * envWidth)
    circ_fnode_agt.setColor(pyflamegpu.GREEN)
    # circ_fnode_agt.setColor(pyflamegpu.ViridisInterpolation("y", -1.0, 1.0))
    # circ_fnode_agt.setColor(pyflamegpu.HSVInterpolation("y", 0.0, 360.0))
    f_max = FIBRE_SEGMENT_K_ELAST * (FIBRE_SEGMENT_EQUILIBRIUM_DISTANCE)
    max_energy = 0.5 * (f_max * f_max) / FIBRE_SEGMENT_K_ELAST
    print("max force, max energy: ", f_max, max_energy)
    circ_fnode_agt.setColor(pyflamegpu.HSVInterpolation.GREENRED("elastic_energy", 0.00000001, max_energy * 1.0))
    square_bcorner_agt = visualisation.addAgent("BCORNER")
    square_bcorner_agt.setModel(pyflamegpu.CUBE)
    square_bcorner_agt.setModelScale(0.025 * envWidth)
    square_bcorner_agt.setColor(pyflamegpu.RED)
            
    coord_boundary = list(env.getPropertyArrayFloat("COORDS_BOUNDARIES"))
    pen = visualisation.newLineSketch(1, 1, 1, 0.8)
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[4])
    pen.addVertex(coord_boundary[0], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[2], coord_boundary[5])
    pen.addVertex(coord_boundary[0], coord_boundary[3], coord_boundary[5])
    pen.addVertex(coord_boundary[1], coord_boundary[3], coord_boundary[5])

    visualisation.activate()

"""
  Execution
"""
if ENSEMBLE:
    # Execute the ensemble using the specified RunPlans
    errs = ensemble.simulate(runs_final)
else:
    simulation.simulate()

"""
  Export Pop
"""
# simulation.exportData("end.xml")

# Join Visualisation
if pyflamegpu.VISUALISATION and VISUALISATION and not ENSEMBLE:
    visualisation.join()

print("--- EXECUTION TIME: %s seconds ---" % (time.time() - start_time))


def manageLogs(steps, is_ensemble, idx):
    global SAVE_EVERY_N_STEPS, SAVE_PICKLE, SHOW_PLOTS, RES_PATH, model_config
    global BPOS_OVER_TIME, BFORCE_OVER_TIME, BFORCE_SHEAR_OVER_TIME, OSCILLATORY_STRAIN_OVER_TIME
    ecm_agent_counts = [None] * len(steps)
    counter = 0
    BFORCE = make_dataclass("BFORCE",
                            [("fxpos", float), ("fxneg", float), ("fypos", float), ("fyneg", float), ("fzpos", float),
                             ("fzneg", float)])
    BFORCE_SHEAR = make_dataclass("BFORCE_SHEAR",
                                  [("fxpos_y", float), ("fxpos_z", float), ("fxneg_y", float), ("fxneg_z", float),
                                   ("fypos_x", float), ("fypos_z", float), ("fyneg_x", float), ("fyneg_z", float),
                                   ("fzpos_x", float), ("fzpos_y", float), ("fzneg_x", float), ("fzneg_y", float)])
    for step in steps:
        stepcount = step.getStepCount()
        if stepcount % SAVE_EVERY_N_STEPS == 0 or stepcount == 1:
            ecm_agents = step.getAgent("FNODE")
            ecm_agent_counts[counter] = ecm_agents.getCount()
            f_bx_pos = ecm_agents.getSumFloat("f_bx_pos")
            f_bx_neg = ecm_agents.getSumFloat("f_bx_neg")
            f_by_pos = ecm_agents.getSumFloat("f_by_pos")
            f_by_neg = ecm_agents.getSumFloat("f_by_neg")
            f_bz_pos = ecm_agents.getSumFloat("f_bz_pos")
            f_bz_neg = ecm_agents.getSumFloat("f_bz_neg")
            f_bx_pos_y = ecm_agents.getSumFloat("f_bx_pos_y")
            f_bx_pos_z = ecm_agents.getSumFloat("f_bx_pos_z")
            f_bx_neg_y = ecm_agents.getSumFloat("f_bx_neg_y")
            f_bx_neg_z = ecm_agents.getSumFloat("f_bx_neg_z")
            f_by_pos_x = ecm_agents.getSumFloat("f_by_pos_x")
            f_by_pos_z = ecm_agents.getSumFloat("f_by_pos_z")
            f_by_neg_x = ecm_agents.getSumFloat("f_by_neg_x")
            f_by_neg_z = ecm_agents.getSumFloat("f_by_neg_z")
            f_bz_pos_x = ecm_agents.getSumFloat("f_bz_pos_x")
            f_bz_pos_y = ecm_agents.getSumFloat("f_bz_pos_y")
            f_bz_neg_x = ecm_agents.getSumFloat("f_bz_neg_x")
            f_bz_neg_y = ecm_agents.getSumFloat("f_bz_neg_y")

            step_bforce = pd.DataFrame([BFORCE(f_bx_pos, f_bx_neg, f_by_pos, f_by_neg, f_bz_pos, f_bz_neg)])
            step_bforce_shear = pd.DataFrame([BFORCE_SHEAR(f_bx_pos_y, f_bx_pos_z, f_bx_neg_y, f_bx_neg_z,
                                                           f_by_pos_x, f_by_pos_z, f_by_neg_x, f_by_neg_z,
                                                           f_bz_pos_x, f_bz_pos_y, f_bz_neg_x, f_bz_neg_y)])
            if counter == 0:
                BFORCE_OVER_TIME = pd.DataFrame([BFORCE(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)])
                BFORCE_SHEAR_OVER_TIME = pd.DataFrame(
                    [BFORCE_SHEAR(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)])
            else:
                # BFORCE_OVER_TIME = BFORCE_OVER_TIME.append(step_bforce, ignore_index=True) # deprecated
                BFORCE_OVER_TIME = pd.concat([BFORCE_OVER_TIME, step_bforce], ignore_index=True)
                # BFORCE_SHEAR_OVER_TIME = BFORCE_SHEAR_OVER_TIME.append(step_bforce_shear, ignore_index=True) # deprecated
                BFORCE_SHEAR_OVER_TIME = pd.concat([BFORCE_SHEAR_OVER_TIME, step_bforce_shear], ignore_index=True)
            counter += 1
    if not is_ensemble:
        print()
        print("============================")
        print("BOUNDARY POSITIONS OVER TIME")
        print(BPOS_OVER_TIME)
        print()
        print("============================")
        print("BOUNDARY FORCES OVER TIME")
        print(BFORCE_OVER_TIME)
        print()
        print("============================")
        print("BOUNDARY SHEAR FORCES OVER TIME")
        print(BFORCE_SHEAR_OVER_TIME)
        print()
        print("============================")
        print("STRAIN OVER TIME")
        print(OSCILLATORY_STRAIN_OVER_TIME)
        print()
    # Saving pickle
    # if SAVE_PICKLE:
        # import pickle

        # file_name = f'output_data_{idx}.pickle'
        # file_path = RES_PATH / file_name
        # with open(str(file_path), 'wb') as file:
            # pickle.dump({'BPOS_OVER_TIME': BPOS_OVER_TIME,
                         # 'BFORCE_OVER_TIME': BFORCE_OVER_TIME,
                         # 'BFORCE_SHEAR_OVER_TIME': BFORCE_SHEAR_OVER_TIME,
                         # 'OSCILLATORY_STRAIN_OVER_TIME': OSCILLATORY_STRAIN_OVER_TIME,
                         # 'model_config': model_config},
                        # file, protocol=pickle.HIGHEST_PROTOCOL)

            # print('Results successfully saved to {0}'.format(file_path))
    # Plotting
    # if SHOW_PLOTS and not is_ensemble:
        # # fig,ax=plt.subplots(2,3)
        # fig = plt.figure()
        # gs = fig.add_gridspec(2, 3)
        # ax1 = fig.add_subplot(gs[0, 0])
        # ax2 = fig.add_subplot(gs[0, 1])
        # ax3 = fig.add_subplot(gs[:, 2])
        # ax4 = fig.add_subplot(gs[1, 0])
        # ax5 = fig.add_subplot(gs[1, 1])
        # # BPOS_OVER_TIME.plot()

        # BPOS_OVER_TIME.plot(ax=ax1)
        # # ax = df['size'].plot(secondary_y=True, color='k', marker='o')
        # ax1.set_xlabel('time step')
        # ax1.set_ylabel('pos')
        # BFORCE_OVER_TIME.plot(ax=ax2)
        # ax2.set_ylabel('normal force')
        # ax2.set_xlabel('time step')
        # BFORCE_SHEAR_OVER_TIME.plot(ax=ax3)
        # ax3.set_ylabel('shear force')
        # ax3.set_xlabel('time step')
        # POISSON_RATIO_OVER_TIME.plot(ax=ax4)
        # ax4.set_ylabel('poisson ratio')
        # ax4.set_xlabel('time step')
        # plt.sca(ax5)
        # plt.plot(BPOS_OVER_TIME['ypos'] - 0.5, BFORCE_OVER_TIME['fypos'])
        # ax5.set_ylabel('normal force')
        # ax5.set_xlabel('disp')

        # fig.tight_layout()

        # if OSCILLATORY_SHEAR_ASSAY:
            # OSCILLATORY_STRAIN_OVER_TIME.plot()
            # fig2 = plt.figure()
            # colors = np.arange(0, STEPS + 1, 1).tolist()
            # plt.scatter(OSCILLATORY_STRAIN_OVER_TIME['strain'].abs(), BFORCE_SHEAR_OVER_TIME['fypos_x'].abs(),
                        # marker='o', c=colors, alpha=0.3, cmap='viridis')
            # plt.xlabel('strain')
            # plt.ylabel('shear force')
            # fig3 = plt.figure()
            # colors = np.arange(0, STEPS + 1, 1).tolist()
            # plt.scatter(OSCILLATORY_STRAIN_OVER_TIME['strain'].abs(), BFORCE_SHEAR_OVER_TIME['fypos_x'], marker='o',
                        # c=colors, alpha=0.3, cmap='viridis')
            # plt.xlabel('strain')
            # plt.ylabel('shear force')

            # fig4, ax41 = plt.subplots()
            # x = colors
            # ax42 = ax41.twinx()
            # ax41.plot(x, OSCILLATORY_STRAIN_OVER_TIME['strain'], 'g-')
            # ax42.plot(x, BFORCE_SHEAR_OVER_TIME['fypos_x'], 'b-')

            # ax41.set_xlabel('steps')
            # ax41.set_ylabel('strain', color='g')
            # ax42.set_ylabel('shear force', color='b')
            # ax42.set_ylim(-35, 35)

        # plt.show()


# Deal with logs
if ENSEMBLE:
    logs = simulation.getLogs()
    for i in range(len(logs)):
        steps = logs[i].getStepLog()
        manageLogs(steps, ENSEMBLE, i)
else:
    logs = simulation.getRunLog()
    steps = logs.getStepLog()
    manageLogs(steps, ENSEMBLE, 0)